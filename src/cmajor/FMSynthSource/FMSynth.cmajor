
// FMSynth.cmajor
// FM Synthesizer with 2 operators (Carrier + Modulator)

/**
    Converts NoteOn/Off events to Frequency and Gate streams
*/
processor NoteToFreqGate
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    output stream float frequencyOut;
    output stream float gateOut;

    float currentNote;
    float currentFreq = 440.0f;
    float currentGate = 0.0f;

    event eventIn (std::notes::NoteOn e)
    {
        currentNote = float(e.pitch);
        currentFreq = std::notes::noteToFrequency(e.pitch);
        currentGate = e.velocity;
    }

    event eventIn (std::notes::NoteOff e)
    {
        if (float(e.pitch) == currentNote)
        {
            currentGate = 0.0f;
        }
    }

    void main()
    {
        loop
        {
            frequencyOut <- currentFreq;
            gateOut <- currentGate;
            advance();
        }
    }
}

/**
    Sine Oscillator for FM synthesis
*/
processor SineOscillator
{
    output stream float out;
    input stream float frequency;
    input stream float phaseModulation; // FM input

    float phase;

    void main()
    {
        loop
        {
            let modulatedPhase = phase + phaseModulation;
            let sample = sin(modulatedPhase * 6.283185307f);

            let phaseIncrement = frequency / float(processor.frequency);
            phase += phaseIncrement;
            while (phase >= 1.0f) phase -= 1.0f;
            while (phase < 0.0f) phase += 1.0f;

            out <- sample;
            advance();
        }
    }
}

/**
    Simple ADSR Envelope
*/
processor Adsr
{
    output stream float out;
    input value float attack [[ name: "Attack", min: 0.0, max: 2.0, init: 0.1 ]];
    input value float decay [[ name: "Decay", min: 0.0, max: 2.0, init: 0.1 ]];
    input value float sustain [[ name: "Sustain", min: 0.0, max: 1.0, init: 0.7 ]];
    input value float release [[ name: "Release", min: 0.0, max: 5.0, init: 0.3 ]];
    input stream float gate;

    float currentLevel;
    int state; // 0: Idle, 1: Attack, 2: Decay, 3: Sustain, 4: Release

    void main()
    {
        loop
        {
            if (gate > 0.0f)
            {
                if (state == 0 || state == 4)
                {
                    state = 1;
                }
            }
            else
            {
                if (state != 0 && state != 4)
                {
                    state = 4;
                }
            }

            if (state == 1) // Attack
            {
                let attackSamples = float(processor.frequency) * attack;
                let increment = attackSamples < 1.0f ? 1.0f : 1.0f / attackSamples;
                currentLevel += increment;
                if (currentLevel >= 1.0f)
                {
                    currentLevel = 1.0f;
                    state = 2;
                }
            }
            else if (state == 2) // Decay
            {
                let decaySamples = float(processor.frequency) * decay;
                let increment = decaySamples < 1.0f ? 1.0f : (1.0f - sustain) / decaySamples;
                currentLevel -= increment;
                if (currentLevel <= sustain)
                {
                    currentLevel = sustain;
                    state = 3;
                }
            }
            else if (state == 3) // Sustain
            {
                currentLevel = sustain;
            }
            else if (state == 4) // Release
            {
                let releaseSamples = float(processor.frequency) * release;
                let increment = releaseSamples < 1.0f ? currentLevel : currentLevel / releaseSamples;
                currentLevel -= increment;
                if (currentLevel <= 0.0f)
                {
                    currentLevel = 0.0f;
                    state = 0;
                }
            }

            out <- currentLevel;
            advance();
        }
    }
}

/**
    FM Voice (2 operators: Modulator -> Carrier)
*/
graph Voice
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    input value float volume;
    input value float carrierRatio;
    input value float modulatorRatio;
    input value float fmIndex;
    
    input adsr.attack;
    input adsr.decay;
    input adsr.sustain;
    input adsr.release;

    output stream float out;

    node
    {
        noteHandler = NoteToFreqGate;
        modulator = SineOscillator;
        carrier = SineOscillator;
        adsr = Adsr;
    }

    connection
    {
        eventIn -> noteHandler.eventIn;
        noteHandler.gateOut -> adsr.gate;

        // Modulator frequency = base frequency * modulator ratio
        (noteHandler.frequencyOut * modulatorRatio) -> modulator.frequency;
        0.0f -> modulator.phaseModulation;

        // Carrier frequency = base frequency * carrier ratio
        (noteHandler.frequencyOut * carrierRatio) -> carrier.frequency;
        
        // FM: modulator output * index -> carrier phase modulation
        (modulator.out * fmIndex) -> carrier.phaseModulation;

        // Final output with envelope and volume
        (carrier.out * adsr.out * volume) -> out;
    }
}

/**
    Main FM Synth Graph
*/
graph FMSynth [[main]]
{
    input event std::midi::Message midiIn;
    input value float volume [[ name: "Master Volume", min: 0.0, max: 1.0, init: 0.3 ]];
    
    // FM Parameters
    input value float carrierRatio [[ name: "Carrier Ratio", min: 0.25, max: 8.0, init: 1.0, step: 0.25 ]];
    input value float modulatorRatio [[ name: "Modulator Ratio", min: 0.25, max: 8.0, init: 1.0, step: 0.25 ]];
    input value float fmIndex [[ name: "FM Index", min: 0.0, max: 10.0, init: 2.0, step: 0.1 ]];
    
    // ADSR
    input value float attack [[ name: "Attack", min: 0.0, max: 2.0, init: 0.1 ]];
    input value float decay [[ name: "Decay", min: 0.0, max: 2.0, init: 0.1 ]];
    input value float sustain [[ name: "Sustain", min: 0.0, max: 1.0, init: 0.7 ]];
    input value float release [[ name: "Release", min: 0.0, max: 5.0, init: 0.3 ]];

    output stream float out;

    node
    {
        voices = Voice[8];
        voiceAllocator = std::voices::VoiceAllocator(8);
    }

    connection
    {
        volume -> voices.volume;
        carrierRatio -> voices.carrierRatio;
        modulatorRatio -> voices.modulatorRatio;
        fmIndex -> voices.fmIndex;
        
        attack -> voices.attack;
        decay -> voices.decay;
        sustain -> voices.sustain;
        release -> voices.release;

        midiIn -> std::midi::MPEConverter -> voiceAllocator;
        voiceAllocator.voiceEventOut -> voices.eventIn;

        voices.out -> out;
    }
}
