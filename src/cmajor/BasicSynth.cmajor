
// BasicSynth.cmajor

/**
    Converts NoteOn/Off events to Frequency and Gate streams for the voice
*/
processor NoteToFreqGate
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    output stream float frequencyOut;
    output stream float gateOut;

    float currentNote;
    float currentFreq = 440.0f;
    float currentGate = 0.0f;

    event eventIn (std::notes::NoteOn e)
    {
        currentNote = float(e.pitch);
        currentFreq = std::notes::noteToFrequency(e.pitch);
        currentGate = e.velocity;
    }

    event eventIn (std::notes::NoteOff e)
    {
        if (float(e.pitch) == currentNote)
        {
            currentGate = 0.0f;
        }
    }

    void main()
    {
        loop
        {
            frequencyOut <- currentFreq;
            gateOut <- currentGate;
            advance();
        }
    }
}

/**
    Multi-waveform Oscillator with Pulse Width
*/
processor Oscillator
{
    output stream float out;
    input stream float frequency;
    input stream float pulseWidth; // 0.0 to 1.0, default 0.5
    input value int waveform [[ name: "Waveform", min: 0, max: 3, init: 0, text: "Sine|Saw|Square|Triangle" ]];

    float phase;

    void main()
    {
        loop
        {
            // Update phase
            let phaseIncrement = frequency / float(processor.frequency);
            phase += phaseIncrement;
            while (phase >= 1.0f) phase -= 1.0f;

            float sample = 0.0f;

            if (waveform == 0) // Sine
            {
                sample = sin(phase * 6.283185307f);
            }
            else if (waveform == 1) // Saw
            {
                sample = phase * 2.0f - 1.0f;
            }
            else if (waveform == 2) // Square
            {
                // Use input pulse width (clamped safely)
                let pw = max(0.01f, min(0.99f, pulseWidth));
                sample = (phase < pw) ? 1.0f : -1.0f;
            }
            else // Triangle
            {
                sample = 4.0f * abs(phase - 0.5f) - 1.0f;
            }

            out <- sample;
            advance();
        }
    }
}

/**
    Simple ADSR Envelope Generator
*/
processor Adsr
{
    output stream float out;
    input value float attack [[ name: "Attack", min: 0.0, max: 10.0, init: 0.1 ]];
    input value float decay [[ name: "Decay", min: 0.0, max: 10.0, init: 0.1 ]];
    input value float sustain [[ name: "Sustain", min: 0.0, max: 1.0, init: 1.0 ]];
    input value float release [[ name: "Release", min: 0.0, max: 10.0, init: 0.1 ]];
    input stream float gate;

    float currentLevel;
    float targetLevel;
    float increment;
    int state; // 0: Idle, 1: Attack, 2: Decay, 3: Sustain, 4: Release

    void main()
    {
        loop
        {
            if (gate > 0.0f)
            {
                if (state == 0 || state == 4) // Attack from idle or release
                {
                    state = 1;
                    targetLevel = 1.0f;
                    // Calculate increment for attack
                    let samples = float(processor.frequency) * attack;
                    if (samples < 1.0f) increment = 1.0f;
                    else increment = 1.0f / samples;
                }
            }
            else
            {
                if (state != 0 && state != 4) // Release
                {
                    state = 4;
                    targetLevel = 0.0f;
                    let samples = float(processor.frequency) * release;
                    if (samples < 1.0f) increment = 1.0f; // Instant
                    else increment = currentLevel / samples; // Decay from current
                }
            }

            if (state == 1) // Attack
            {
                currentLevel += increment;
                if (currentLevel >= 1.0f)
                {
                    currentLevel = 1.0f;
                    state = 2; // Decay
                    targetLevel = sustain;
                    let samples = float(processor.frequency) * decay;
                    if (samples < 1.0f) increment = 1.0f;
                    else increment = (1.0f - sustain) / samples;
                }
            }
            else if (state == 2) // Decay
            {
                currentLevel -= increment;
                if (currentLevel <= sustain)
                {
                    currentLevel = sustain;
                    state = 3; // Sustain
                }
            }
            else if (state == 4) // Release
            {
                currentLevel -= increment;
                if (currentLevel <= 0.0f)
                {
                    currentLevel = 0.0f;
                    state = 0; // Idle
                }
            }

            out <- currentLevel;
            advance();
        }
    }
}

/**
    Simple Low Pass Filter
*/
processor LowPass
{
    input stream float in;
    input stream float frequency; // Modulated Frequency
    input value float q [[ name: "Resonance", min: 0.1, max: 10.0, init: 1.0 ]]; 
    output stream float out;

    float z1;

    void main()
    {
        loop
        {
            // Clamp frequency
            let f = max(20.0f, min(20000.0f, frequency));
            
            // Simple 1-pole lowpass
            let dt = 1.0f / float(processor.frequency);
            let rc = 1.0f / (6.2831853f * f);
            let alpha = dt / (rc + dt);
            
            let nextSample = z1 + alpha * (in - z1);
            out <- nextSample;
            z1 = nextSample;
            
            advance();
        }
    }
}

/**
    LFO Processor
*/
processor LFO
{
    output stream float out;
    input value float frequency [[ name: "Rate", min: 0.1, max: 20.0, init: 1.0 ]];
    input value float depth [[ name: "Depth", min: 0.0, max: 2000.0, init: 0.0 ]]; // Modulate up to +/- 2000Hz

    float phase;

    void main()
    {
        loop
        {
            let phaseIncrement = frequency / float(processor.frequency);
            phase += phaseIncrement;
            while (phase >= 1.0f) phase -= 1.0f;

            // Sine LFO
            let lfo = sin(phase * 6.283185307f);
            
            out <- lfo * depth;
            advance();
        }
    }
}

/**
    Helper to unpack integer to MIDI message for robust JS communication
*/
processor IntToMidi
{
    output event std::midi::Message messageOut;
    input event int32 intIn;

    event intIn (int32 v)
    {
        // Use constructor syntax
        std::midi::Message m = std::midi::Message(v);
        messageOut <- m;
    }
}

/**
     Single Voice Graph
*/
graph Voice
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    input value float volume;
    input osc.waveform;
    input value float pulseWidth; // Shared param
    
    input adsr.attack;
    input adsr.decay;
    input adsr.sustain;
    input adsr.release;
    
    input value float cutoff;
    input filter.q; // Resonance
    
    input stream float lfoMod; // LFO Modulation Input

    output stream float out;

    node
    {
        noteHandler = NoteToFreqGate;
        osc = Oscillator;
        adsr = Adsr;
        filter = LowPass;
    }

    connection
    {
        eventIn -> noteHandler.eventIn;
        noteHandler.frequencyOut -> osc.frequency;
        noteHandler.gateOut -> adsr.gate;

        pulseWidth -> osc.pulseWidth;

        osc.out -> filter.in;
        
        // Filter Cutoff Modulation (Base + LFO)
        (cutoff + lfoMod) -> filter.frequency;

        (filter.out * adsr.out * volume) -> out;
    }
}


graph BasicSynth [[main]]
{
    input event std::midi::Message midiIn;
    input value float volume [[ name: "Master Volume", min: 0.0, max: 1.0, init: 0.5 ]];
    
    // Oscillator
    input value int waveform [[ name: "Waveform", min: 0, max: 3, init: 0, text: "Sine|Saw|Square|Triangle" ]];
    input value float pulseWidth [[ name: "Pulse Width", min: 0.01, max: 0.99, init: 0.5 ]];
    
    // ADSR
    input value float attack [[ name: "Attack", min: 0.0, max: 10.0, init: 0.1 ]];
    input value float decay [[ name: "Decay", min: 0.0, max: 10.0, init: 0.1 ]];
    input value float sustain [[ name: "Sustain", min: 0.0, max: 1.0, init: 1.0 ]];
    input value float release [[ name: "Release", min: 0.0, max: 10.0, init: 0.1 ]];

    // Filter
    input value float cutoff [[ name: "Cutoff", min: 20.0, max: 10000.0, init: 2000.0 ]];
    input value float resonance [[ name: "Resonance", min: 0.1, max: 10.0, init: 1.0 ]];

    // LFO
    input value float lfoRate [[ name: "LFO Rate", min: 0.1, max: 20.0, init: 1.0 ]];
    input value float lfoDepth [[ name: "LFO Depth", min: 0.0, max: 2000.0, init: 0.0 ]];

    output stream float out;

    node
    {
        voices = Voice[8];
        voiceAllocator = std::voices::VoiceAllocator(8);
        lfo = LFO;
    }

    connection
    {
        // Parameter distribution
        volume -> voices.volume;
        waveform -> voices.waveform;
        pulseWidth -> voices.pulseWidth;
        
        attack -> voices.attack;
        decay -> voices.decay;
        sustain -> voices.sustain;
        release -> voices.release;
        
        cutoff -> voices.cutoff;
        resonance -> voices.q;
        
        // LFO
        lfoRate -> lfo.frequency;
        lfoDepth -> lfo.depth;
        lfo.out -> voices.lfoMod;

        // MIDI Parsing & Voice Allocation
        midiIn -> std::midi::MPEConverter -> voiceAllocator;
        voiceAllocator.voiceEventOut -> voices.eventIn;

        // Summing Output
        voices.out -> out;
    }
}
